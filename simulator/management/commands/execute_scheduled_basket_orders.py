# Generated by ChatGPT on 2026-02-07

from __future__ import annotations

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils import timezone

from competitions.models import CompetitionStatus, ParticipantStatus
from simulator.models import (
    ScheduledBasketOrder,
    ScheduledBasketOrderStatus,
)
from simulator.services import execute_basket_order


MAX_ATTEMPTS_DEFAULT = 3


class Command(BaseCommand):
    help = "Execute pending scheduled basket orders for active competitions (cron-friendly)."

    def add_arguments(self, parser):
        parser.add_argument(
            "--max-attempts",
            type=int,
            default=MAX_ATTEMPTS_DEFAULT,
            help="Max attempts before marking an order FAILED (default: 3).",
        )

    def handle(self, *args, **options):
        now = timezone.now()
        max_attempts = int(options.get("max_attempts") or MAX_ATTEMPTS_DEFAULT)
        max_attempts = max(1, min(max_attempts, 25))

        executed = 0
        failed = 0
        skipped = 0

        # Process FIFO to keep it predictable for users.
        with transaction.atomic():
            qs = (
                ScheduledBasketOrder.objects.select_for_update()
                .select_related("participant", "participant__competition")
                .filter(
                    status=ScheduledBasketOrderStatus.PENDING,
                    attempts__lt=max_attempts,
                    participant__status=ParticipantStatus.ACTIVE,
                    participant__competition__status=CompetitionStatus.PUBLISHED,
                    participant__competition__week_start_at__lte=now,
                    participant__competition__week_end_at__gte=now,
                )
                .order_by("created_at", "id")
            )

            orders = list(qs)
            if not orders:
                self.stdout.write("No scheduled basket orders to execute.")
                return

            for sbo in orders:
                legs = list(sbo.legs.all().only("instrument_id", "pct"))
                pct_by_instrument_id = {l.instrument_id: l.pct for l in legs}

                result = execute_basket_order(
                    participant_id=sbo.participant_id,
                    basket_name=sbo.basket_name,
                    side=sbo.side,
                    total_amount=sbo.total_amount,
                    pct_by_instrument_id=pct_by_instrument_id,
                )

                if result.ok:
                    sbo.status = ScheduledBasketOrderStatus.EXECUTED
                    sbo.executed_at = now
                    sbo.last_error = ""
                    sbo.save(update_fields=["status", "executed_at", "last_error"])
                    executed += 1
                    continue

                # Failure: increment attempts and decide whether to fail permanently.
                sbo.attempts = int(sbo.attempts or 0) + 1
                sbo.last_error = (result.message or "")[:2000]
                if sbo.attempts >= max_attempts:
                    sbo.status = ScheduledBasketOrderStatus.FAILED
                    failed += 1
                else:
                    # Keep pending for retry.
                    skipped += 1
                sbo.save(update_fields=["status", "attempts", "last_error"])

        self.stdout.write(
            f"Executed {executed} scheduled basket order(s). Failed {failed}. Pending for retry {skipped}."
        )

